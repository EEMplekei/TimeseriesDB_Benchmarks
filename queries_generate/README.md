

# Query generation scripts

This folders contains the scripts for generating Timeseries queries using `tsbs_generate_queries` and a helper script to automate the generation with different query counts. It generates 1 and 10 queries to test the scaling of the database against multiple queries execution of the same kind.

## Prerequisites

- [tsbs_generate_queries](https://github.com/timescale/tsbs) must be installed and available in your system. It comes with TSBS package, whose installation is in the [single_node README](../single_node/README.md)

## Usage

### 1. Generate Queries

The script `generate_queries.sh` generates timeseries queries using `tsbs_generate_queries`. It takes the number of queries as a command-line argument.

```bash
bash generate_queries.sh <number_of_queries>
```
Replace _<number_of_queries>_ with disirable number of queries.

*This should no be used on it's own and the helper `generate_all_queries.sh` script should be used*

### 2. Generate All Queries Script

The helper script `generate_all_queries.sh` automates the generation of queries for multiple query counts. It calls `generate_queries.sh` with predefined values.

```bash
bash generate_all_queries.sh
```
## Directory Structure
A folder named _queries_ is generated containing all the queries for the two databases, InfluxDB and TimescaleDB.

- `queries`: Main folder for generated queries with subfolders for different query counts..
  - `queries/{number_of_queries}_queries/`: Subfolder containing the specified amount of queries for each query type for both databases.
    - `queries_timescaledb/`: Subfolder containing queries in TimescaleDB format.
      - `small/`: Subfolder for small-sized dataset.
      - `medium/`: Subfolder for medium-sized dataset.
      - `large/`: Subfolder for large-sized dataset.
    - `queries_influx/`: Subfolder containing queries in InfluxDB format.
      - `small/`: Subfolder for small-sized dataset.
      - `medium/`: Subfolder for medium-sized dataset.
      - `large/`: Subfolder for large-sized dataset.


## Queries Generated

Here we describe the queries generated by TSBS that we used for benchmarking.


##### Average driver driving duration per day - avg-daily-driving-duration
Calculate average daily driving duration per driver
```sql
SELECT count("mv")/6 as "hours driven" 
FROM 
(
  SELECT mean("velocity") as "mv" 
  FROM "readings" 
  WHERE time > '%s' AND time < '%s' 
  GROUP BY time(10m),"fleet", "name", "driver"
) 
WHERE time > '%s' AND time < '%s' 
GROUP BY time(1d),"fleet", "name", "driver"
```

This SQL query calculates the total hours driven per day for each unique combination of fleet, name, and driver based on velocity readings from the "readings" table. The query involves aggregations (mean and sum) and grouping by time, fleet, name, and driver and the use of time intervals (10 minutes and 1 day) in both the inner and main queries contributes to the complexity.


##### Average driver driving session without stopping per day - avg-daily-driving-session
Finds the average driving session without stopping per driver per day.
```sql
WITH driver_status
		AS (
			SELECT tags_id, time_bucket('10 mins', TIME) AS ten_minutes, avg(velocity) > 5 AS driving
			FROM readings
			GROUP BY tags_id, ten_minutes
			ORDER BY tags_id, ten_minutes
			), driver_status_change
		AS (
			SELECT tags_id, ten_minutes AS start, lead(ten_minutes) OVER (PARTITION BY tags_id ORDER BY ten_minutes) AS stop, driving
			FROM (
				SELECT tags_id, ten_minutes, driving, lag(driving) OVER (PARTITION BY tags_id ORDER BY ten_minutes) AS prev_driving
				FROM driver_status
				) x
			WHERE x.driving <> x.prev_driving
			)
		SELECT t.%s, time_bucket('24 hours', start) AS day, avg(age(stop, start)) AS duration
		FROM tags t
		INNER JOIN driver_status_change d ON t.id = d.tags_id
		WHERE t.%s IS NOT NULL
		AND d.driving = true
		GROUP BY name, day
		ORDER BY name, day
```

This query calculates the average duration of driving sessions without stopping per driver per day. The data is obtained from a table named readings that contains information about drivers, including their velocity at different timestamps. The query uses two common table expressions (CTEs) named driver_status and driver_status_change to preprocess and extract relevant information.


##### Average load per truck model per fleet - avg-load
Calculate average load per truck model per fleet
```sql
SELECT mean("ml") AS mean_load_percentage 
FROM (
  SELECT "current_load"/"load_capacity" AS "ml" 
  FROM "diagnostics" 
  GROUP BY "name", "fleet", "model"
) 
GROUP BY "fleet", "model"
```

This SQL query calculates the average load percentage for each fleet and model based on data from a "diagnostics" table. The main goal is to find the mean load percentage by dividing the "current_load" by the "load_capacity" for each unique combination of "name", "fleet", and "model". For its performance demands, this query involves basic aggregation (mean) and division operations, which are generally efficient. Although, grouping by multiple columns ("name," "fleet," "model") in the inner query may incur some computational cost. It is imperative to acknowledge that this query traverses the entire dataset, thereby giving rise to consequential implications on performance.


##### Average vs projected fuel consumption per fleet - avg-vs-projected-fuel-consumption
Calculate average vs. projected fuel consumption per fleet
```sql
SELECT mean("fuel_consumption") AS "mean_fuel_consumption", mean("nominal_fuel_consumption") AS "nominal_fuel_consumption" 
FROM "readings" 
WHERE "velocity" > 1 
GROUP BY "fleet"
```

This SQL query calculates the average fuel consumption and nominal fuel consumption for each fleet, based on data from the "readings" table. The query specifically considers only readings where the velocity is greater than 1. In terms of performance, this query involves basic aggregation functions (mean) on fuel consumption and nominal fuel consumption, which are generally efficient operations and the filtering condition ("velocity" > 1) may reduce the dataset size and improve performance (although in most real world data this condition will not change the dataset size in a significant manner). However, grouping by "fleet" is a key factor in the performance, the impact depends on the size of the dataset and the number of distinct fleets.


##### Truck breakdown frequency per model - breakdown-frequency
Calculate breakdown frequency by truck model
```sql
FROM (SELECT difference("broken_down") AS "state_changed" 
		 FROM (SELECT floor(2*(sum("nzs")/count("nzs")))/floor(2*(sum("nzs")/count("nzs"))) AS "broken_down" 
		  FROM (SELECT "model", "status"/"status" AS nzs 
		   FROM "diagnostics" 
		   WHERE time >= '%s' AND time < '%s') 
		  WHERE time >= '%s' AND time < '%s' 
		  GROUP BY time(10m),"model") 
		 GROUP BY "model") 
		WHERE "state_changed" = 1 
		GROUP BY "model"
```

This SQL query calculates the breakdown frequency for each model based on data from the "diagnostics" table. It involves several nested queries to compute the breakdown state changes and then filters and groups the results accordingly. The query is computationally demanding due to multiple levels of aggregations and nested queries, which can be computationally demanding as well as use of ratios and normalization in the innermost and middle queries which adds complexity to the computation and the fact that there is grouping by time and model, along with filtering based on state changes that also impacts performance.


##### Daily truck activity per fleet per model - daily-activity
Get the number of hours truck has been active (vs. out-of-commission) per day per fleet

```sql
SELECT count("ms")/144 
		FROM (SELECT mean("status") AS ms 
		 FROM "diagnostics" 
		 WHERE time >= '%s' AND time < '%s' 
		 GROUP BY time(10m), "model", "fleet") 
		WHERE time >= '%s' AND time < '%s' AND "ms"<1 
		GROUP BY time(1d), "model", "fleet"
```

This SQL query calculates the daily activity count for each model and fleet based on data from the "diagnostics" table. It involves aggregating the mean status over 10-minute intervals, filtering the results, and then calculating the count of intervals where the mean status is less than 1 for each day. The query involves aggregating the mean status over 10-minute intervals, which is generally efficient. However, filtering based on time ranges and status as well as grouping by time, model, and fleet adds computational load.


##### Trucks with high load
Fetch trucks with high current load (over 90% load capacity)

```sql
SELECT "name", "driver", "current_load", "load_capacity" 
		FROM (SELECT  "current_load", "load_capacity" 
		 FROM "diagnostics" WHERE fleet = '%s' 
		 GROUP BY "name","driver" 
		 ORDER BY "time" DESC 
		 LIMIT 1) 
		WHERE "current_load" >= 0.9 * "load_capacity" 
		GROUP BY "name" 
		ORDER BY "time" DESC
```

This SQL query retrieves information about instances where the current load is at least 90% of the load capacity for each driver in a specified fleet. It involves selecting the latest load-related data for each driver in the fleet and filtering the results based on the load condition. The inner subquery involves grouping by "name" and "driver," which could have performance implications, depending on the size of the dataset. Grouping and ordering in the main query add additional computational load. Lastly, the condition in the main query involves filtering based on load conditions, which may impact performance. Overall, it a generally demanding query.


##### Last location per truck - last-loc
Fetch real-time (i.e. last) location of each truck

```sql
SELECT "latitude", "longitude" 
		FROM "readings" 
		WHERE "fleet"='%s' 
		GROUP BY "name","driver" 
		ORDER BY "time" 
		LIMIT 1
```

This SQL query retrieves the last known latitude and longitude for each unique combination of "name" and "driver" in a specified fleet based on data from the "readings" table. It involves filtering and ordering the results to obtain the most recent location information. Filtering and grouping by "name" and "driver" may have performance implications, depending on the size of the dataset. In addition, ordering by time and limiting the result to one row add some computational load, especially when dealing with large datasets.


##### Trucks with longer driving sessions - long-driving-sessions
Get trucks which haven't rested for at least 20 mins in the last 4 hours

```sql
SELECT "name","driver" 
		FROM(SELECT count(*) AS ten_min 
		 FROM(SELECT mean("velocity") AS mean_velocity 
		  FROM readings 
		  WHERE "fleet" = '%s' AND time > '%s' AND time <= '%s' 
		  GROUP BY time(10m),"name","driver") 
		 WHERE "mean_velocity" > 1 
		 GROUP BY "name","driver") 
		WHERE ten_min_mean_velocity > %d
```

This SQL query identifies trucks in a specified fleet that haven't rested for at least 20 minutes within the last 4 hours. It focuses on trucks where the mean velocity is consistently greater than 1 over 10-minute intervals. The nested aggregations and filtering based on velocity conditions add complexity to the query and grouping by time, "name," and "driver" in the innermost query may have performance implications.


##### Trucks with low fuel - low-fuel
Fetch all trucks with low fuel (less than 10%)

```sql
SELECT "name", "driver", "fuel_state" 
		FROM "diagnostics" 
		WHERE "fuel_state" <= 0.1 AND "fleet" = '%s' 
		GROUP BY "name" 
		ORDER BY "time" DESC 
		LIMIT 1
```

This SQL query retrieves information about trucks in a specified fleet with low fuel states. It selects the most recent records where the fuel state is less than or equal to 10% and groups the results by the truck's name. The query aims to identify trucks that are currently low on fuel within the specified fleet. The query involves filtering and grouping by "name," which may have performance implications, depending on the size of the dataset. In addition, ordering by time and limiting the result to one row add some computational load. 


##### Stationary trucks - stationary-trucks
Fetch all trucks that are stationary (low avg velocity in last 10 mins)

```sql
SELECT "name", "driver" 
		FROM(SELECT mean("velocity") as mean_velocity 
		 FROM "readings" 
		 WHERE time > '%s' AND time <= '%s' 
		 GROUP BY time(10m),"name","driver","fleet"  
		 LIMIT 1) 
		WHERE "fleet" = '%s' AND "mean_velocity" < 1 
		GROUP BY "name"
```

This SQL query identifies trucks in a specified fleet that have been stationary, with a mean velocity less than 1, during a specific time range. It calculates the mean velocity over 10-minute intervals for each unique combination of "name," "driver," and "fleet" within the given time range, and then filters and groups the results based on the specified conditions. The inner query involves aggregating mean velocity and grouping by time, "name," "driver," and "fleet," which are performance demanding and the main query involves filtering based on fleet and mean velocity condition and further grouping by "name," which adds computational load.